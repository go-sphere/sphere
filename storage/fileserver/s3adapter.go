package fileserver

import (
	"bytes"
	"context"
	"fmt"
	"net/http"
	"net/url"
	"time"

	"github.com/go-sphere/sphere/cache"
	"github.com/go-sphere/sphere/server/httpx"
	"github.com/go-sphere/sphere/storage"
	"github.com/google/uuid"
)

var _ storage.CDNStorage = (*S3Adapter)(nil)

// Config holds the configuration for S3 adapter operations.
type Config struct {
	PublicBase string `json:"public_base" yaml:"public_base"`
	PutPrefix  string `json:"put_prefix" yaml:"put_prefix"`
}

// S3Adapter provides a caching layer and upload token generation for S3-compatible storage.
// It extends a base storage implementation with temporary upload URL generation capabilities.
type S3Adapter struct {
	storage.Storage

	config *Config
	cache  cache.ByteCache
}

// NewS3Adapter creates a new S3 adapter with caching and upload token generation.
// It wraps an existing storage implementation to add temporary upload URL functionality.
func NewS3Adapter(config *Config, cache cache.ByteCache, store storage.Storage) *S3Adapter {
	return &S3Adapter{
		Storage: store,
		config:  config,
		cache:   cache,
	}
}

// createFileKey generates a temporary UUID-based key for file uploads with expiration.
// The key maps to the actual filename in the cache for a limited time.
func (a *S3Adapter) createFileKey(ctx context.Context, filename string, expiration time.Duration) (string, error) {
	id, err := uuid.NewUUID()
	if err != nil {
		return "", err
	}
	err = a.cache.SetWithTTL(ctx, id.String(), []byte(filename), expiration)
	if err != nil {
		return "", err
	}
	return id.String(), nil
}

// GenerateUploadToken creates a temporary upload URL and token for client-side uploads.
// Returns the upload URL, final storage key, and public access URL.
func (a *S3Adapter) GenerateUploadToken(ctx context.Context, fileName string, dir string, nameBuilder func(filename string, dir ...string) string) ([3]string, error) {
	key := nameBuilder(fileName, dir)
	newToken, err := a.createFileKey(ctx, key, time.Minute*5)
	if err != nil {
		return [3]string{}, err
	}
	uri, err := url.JoinPath(a.config.PublicBase, a.config.PutPrefix, newToken)
	if err != nil {
		return [3]string{}, err
	}
	return [3]string{
		uri,
		key,
		a.GenerateURL(key),
	}, nil
}

// RegisterPutFileUploader registers a Gin route handler for PUT-based file uploads.
// It handles temporary upload URLs generated by GenerateUploadToken and stores files
// using the original filename mapped from the temporary key.
func (a *S3Adapter) RegisterPutFileUploader(route httpx.Router, options ...UploadOption) {
	opts := newUploadOptions(options...)
	route.Handle(http.MethodPut, "/:key", func(ctx httpx.Context) error {
		key := ctx.Param("key")
		if key == "" {
			opts.abortWithError(ctx, http.StatusBadRequest, fmt.Errorf("key is required"))
			return nil
		}
		filename, found, err := a.cache.Get(ctx, key)
		if err != nil {
			opts.abortWithError(ctx, http.StatusBadRequest, err)
			return nil
		}
		if !found {
			opts.abortWithError(ctx, http.StatusBadRequest, fmt.Errorf("key expires or not found"))
			return nil
		}
		err = a.cache.Del(ctx, key)
		if err != nil {
			opts.abortWithError(ctx, http.StatusInternalServerError, err)
			return nil
		}
		data, err := ctx.GetBodyRaw()
		if err != nil {
			opts.abortWithError(ctx, http.StatusInternalServerError, err)
			return nil
		}
		uploadKey, err := a.UploadFile(ctx, bytes.NewReader(data), string(filename))
		if err != nil {
			opts.abortWithError(ctx, http.StatusInternalServerError, err)
			return nil
		}
		opts.successWithData(ctx, uploadKey, a.GenerateURL(uploadKey))
		return nil
	})
}

func (a *S3Adapter) RegisterFileDownloader(route httpx.Router, options ...DownloaderOption) {
	RegisterFileDownloader(route, a.Storage, options...)
}
