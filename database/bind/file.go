package bind

import (
	_ "embed"
	"go/format"
	"path"
	"strconv"
	"strings"
)

// GenFileConf holds configuration for generating a complete Go file with multiple binding functions.
// It coordinates the generation of binding code for multiple entities and their operations.
type GenFileConf struct {
	Entities     []GenFileEntityConf
	ExtraImports [][2]string
}

// GenFileEntityConf represents configuration for a single entity's binding generation.
// It defines the actions to generate and how to build configuration for each action.
type GenFileEntityConf struct {
	Actions       []any
	ConfigBuilder func(act any) *GenFuncConf
}

// GenFile generates a complete Go source file containing binding functions for multiple entities.
// It creates properly formatted Go code with imports and multiple binding functions
// based on the provided configuration. Returns formatted Go source code or an error.
func GenFile(config *GenFileConf) (string, error) {
	var file strings.Builder
	var body strings.Builder

	imports := [][2]string{
		extractPackageImport(Options{}),
	}
	for _, item := range config.Entities {
		for i, act := range item.Actions {
			conf := item.ConfigBuilder(act)
			imports = append(imports,
				extractPackageImport(act),
				extractPackageImport(conf.source),
				extractPackageImport(conf.target),
			)
			if i == 0 {
				entityName := strings.ToLower(extractTypeName(conf.source))
				imports = append(imports, [2]string{
					path.Join(extractPackagePath(conf.source), entityName),
					entityName,
				})
			}
			funcContent, err := GenBindFunc(conf)
			if err != nil {
				return "", err
			}
			body.WriteString(funcContent)
			body.WriteString("\n")
		}
	}
	imports = append(imports, config.ExtraImports...)

	file.WriteString("// Code generated by Sphere. DO NOT EDIT.\n")
	file.WriteString("package render\n\n")
	file.WriteString("import (\n")
	for _, imp := range deduplicateImports(imports) {
		file.WriteString("\t")
		if imp[1] != "" {
			file.WriteString(imp[1] + " ")
		}
		file.WriteString(strconv.Quote(imp[0]) + "\n")
	}
	file.WriteString(")\n\n")
	file.WriteString(body.String())

	source, err := format.Source([]byte(file.String()))
	if err != nil {
		return "", err
	}
	return string(source), nil
}
